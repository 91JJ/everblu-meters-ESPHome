esphome:
  name: water-meter
  friendly_name: EverBlue-Water-Monitor
  on_boot:
    priority: 600
    then:
      - delay: 2s
      - lambda: |-
          if (!isnan(id(frequency_number).state)) {
            id(cc1101).set_frequency(id(frequency_number).state);
          }
          if (!isnan(id(meter_year_number).state)) {
            id(cc1101).set_meter_year(static_cast<uint8_t>(id(meter_year_number).state));
          }
          if (!isnan(id(meter_serial_number).state)) {
            id(cc1101).set_meter_serial(static_cast<uint32_t>(id(meter_serial_number).state));
          }

esp8266:
  board: nodemcu

external_components:
  - source:
      type: local
      path: .

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${name} FallbackHotspot"
    password: !secret fallback_hotspot_password

ota:
  - platform: esphome

web_server:
  port: 80
  version: 3

api:

logger:
  level: DEBUG

debug:
  update_interval: 60s

globals:
  - id: last_auto_read_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

spi:
  clk_pin: D5
  mosi_pin: D7
  miso_pin: D6

cc1101_component:
  id: cc1101
  cs_pin: D8
  gdo0_pin:
    number: D1
    mode: INPUT_PULLUP
  time_id: sntp_time
  liters:
    name: "Water Meter Liters"
    unit_of_measurement: "L"
    icon: "mdi:water"
    accuracy_decimals: 0
    device_class: "water"
    state_class: "total_increasing"
  counter:
    name: "Water Meter Counter"
    unit_of_measurement: "reads"
    icon: "mdi:counter"
    accuracy_decimals: 0
    state_class: "measurement"
  battery:
    name: "Water Meter Battery"
    unit_of_measurement: "%"
    device_class: "battery"
    accuracy_decimals: 0
    state_class: "measurement"
  time_start:
    name: "Water Meter Time Start"
    unit_of_measurement: "h"
    icon: "mdi:clock"
    accuracy_decimals: 0
  time_end:
    name: "Water Meter Time End"
    unit_of_measurement: "h"
    icon: "mdi:clock"
    accuracy_decimals: 0
  rssi:
    name: "CC1101 Last RSSI"
    icon: "mdi:signal"
    entity_category: diagnostic
  tuned_frequency:
    name: "CC1101 Tuned Frequency"
    icon: "mdi:radio"
    entity_category: diagnostic
  json_sensor:
    name: "Water Meter JSON"
    icon: "mdi:code-json"
  timestamp_sensor:
    name: "Water Meter Timestamp"
    device_class: "timestamp"
    icon: "mdi:clock"

sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    icon: "mdi:wifi"
    entity_category: diagnostic
    update_interval: 60s

  - platform: uptime
    id: uptime_seconds
    internal: true
    update_interval: 60s

  - platform: debug
    free:
      name: "Heap Free"
      icon: "mdi:memory"
      entity_category: diagnostic
    fragmentation:
      name: "Heap Fragmentation"
      icon: "mdi:puzzle"
      entity_category: diagnostic
    block:
      name: "Heap Max Block"
      icon: "mdi:memory-arrow-up"
      entity_category: diagnostic
    loop_time:
      name: "Loop Time"
      icon: "mdi:timer-outline"
      entity_category: diagnostic
    cpu_frequency:
      name: "CPU Frequency"
      icon: "mdi:speedometer"
      entity_category: diagnostic

text_sensor:
  - platform: debug
    device:
      name: "Device Info"
      icon: "mdi:chip"
      entity_category: diagnostic
    reset_reason:
      name: "Reset Reason"
      icon: "mdi:restart"
      entity_category: diagnostic

  - platform: template
    name: "Uptime"
    icon: "mdi:timer-outline"
    entity_category: diagnostic
    update_interval: 60s
    lambda: |-
      const uint32_t s = (uint32_t) id(uptime_seconds).state;
      const uint32_t days = s / 86400;
      const uint32_t hours = (s % 86400) / 3600;
      const uint32_t mins = (s % 3600) / 60;
      const uint32_t secs = s % 60;
      char buf[32];
      if (days > 0) {
        snprintf(buf, sizeof(buf), "%ud %02u:%02u:%02u", (unsigned) days, (unsigned) hours, (unsigned) mins, (unsigned) secs);
      } else {
        snprintf(buf, sizeof(buf), "%02u:%02u:%02u", (unsigned) hours, (unsigned) mins, (unsigned) secs);
      }
      return std::string(buf);

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      icon: "mdi:ip"
      entity_category: diagnostic
    ssid:
      name: "Connected SSID"
      icon: "mdi:wifi"
      entity_category: diagnostic
    bssid:
      name: "Connected BSSID"
      icon: "mdi:router-wireless"
      entity_category: diagnostic
    mac_address:
      name: "MAC Address"
      icon: "mdi:identifier"
      entity_category: diagnostic

number:
  - platform: template
    name: "1. Frequency"
    id: frequency_number
    icon: "mdi:radio"
    entity_category: config
    mode: box
    min_value: 433.0
    max_value: 434.0
    step: 0.2
    unit_of_measurement: "MHz"
    restore_value: false
    initial_value: 433.82
    optimistic: true
    set_action:
      - lambda: |-
          id(cc1101).set_frequency(x);

  - platform: template
    name: "2. Meter Serial / ID"
    id: meter_serial_number
    icon: "mdi:identifier"
    entity_category: config
    mode: box
    min_value: 0
    max_value: 999999
    step: 1
    restore_value: true
    initial_value: 123456
    optimistic: true
    set_action:
      - lambda: |-
          id(cc1101).set_meter_serial(static_cast<uint32_t>(x));

  - platform: template
    name: "3. Meter Year"
    id: meter_year_number
    icon: "mdi:calendar"
    entity_category: config
    mode: box
    min_value: 0
    max_value: 99
    step: 1
    restore_value: true
    initial_value: 12
    optimistic: true
    set_action:
      - lambda: |-
          id(cc1101).set_meter_year(static_cast<uint8_t>(x));

  - platform: template
    name: "4. Refresh Rate"
    id: refresh_rate_hours_number
    icon: "mdi:timer-cog"
    entity_category: config
    mode: box
    min_value: 0
    max_value: 168
    step: 1
    unit_of_measurement: "h"
    restore_value: true
    initial_value: 0
    optimistic: true
    set_action:
      - lambda: |-
          // Default is disabled (0) to protect meter battery.
          if (x <= 0) {
            id(last_auto_read_ms) = 0;
          } else {
            // Start the interval from now; use "Read Meter Now" if you want an immediate read.
            id(last_auto_read_ms) = millis();
          }

button:
  - platform: template
    name: "5. Read Meter Now"
    icon: "mdi:water-sync"
    entity_category: config
    on_press:
      - lambda: |-
          id(cc1101).update_meter_data();

  - platform: restart
    name: "Reboot Device"
    icon: "mdi:restart"
    entity_category: diagnostic

binary_sensor:
  - platform: status
    name: "Device Status"
    icon: "mdi:lan-connect"
    entity_category: diagnostic

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/London
    on_time_sync:
      then:
        - lambda: |-
            // Trigger a read soon after time becomes valid (avoids waiting for the first 5min interval).
            auto current_time = id(sntp_time).now();
            const int refresh_hours = (int) id(refresh_rate_hours_number).state;
            if (refresh_hours > 0 && current_time.is_valid() && current_time.hour >= 7 && current_time.hour <= 17) {
              id(cc1101).update_meter_data();
              id(last_auto_read_ms) = millis();
            }

interval:
  - interval: 1min
    then:
      - lambda: |-
          const int refresh_hours = (int) id(refresh_rate_hours_number).state;
          if (refresh_hours <= 0) return;

          auto current_time = id(sntp_time).now();
          if (!current_time.is_valid()) return;
          if (current_time.hour < 7 || current_time.hour > 17) return;

          const uint32_t refresh_ms = (uint32_t) refresh_hours * 3600000UL;
          const uint32_t now_ms = millis();
          const uint32_t elapsed_ms = now_ms - id(last_auto_read_ms);
          if (id(last_auto_read_ms) == 0 || elapsed_ms >= refresh_ms) {
            id(cc1101).update_meter_data();
            id(last_auto_read_ms) = now_ms;
          }